/*jshint white:false, eqnull:true, immed:false, forin:false, globalstrict:true, node:true */
'use strict';

// Generated by CoffeeScript 1.6.2
var Sqlite3WebApiKit, Type, async, http, os, sqlite3, url;

http = require('http');

async = require('async');

url = require('url');

os = require('os');

sqlite3 = require('sqlite3').verbose();

Type = require('./type');

/**
* モジュール本体
*
* - クラスではなく単一のオブジェクトとしてロードすることを想定したモジュール
* - モジュールロード時に自動的にオブジェクトが作成される
*
* @class Sqlite3WebApiKit
* @see http://blog.asial.co.jp/1101
*/


Sqlite3WebApiKit = (function() {
  var _addMethod, _apiMethods, _clearMethod, _close, _db, _dbname, _errMessage, _error, _fieldsFromSql, _get, _indexesFromSql, _listen, _methods, _onopen, _open, _post, _postMulti, _removeMethod, _requestHook, _schema, _server, _setHook, _shutdown;

  _apiMethods = require('./api-method');
  _db = null;
  _onopen = null;
  _requestHook = null;
  _server = null;
  /**
  * 開いているDB名(ファイルパス)を取得
  *
  * @public
  * @method dbname
  * @return {String} DB名
  */

  _dbname = function() {
    return _db.filename;
  };
  /**
  * DBを開く
  *
  * @public
  * @method open
  * @param dbname {String} DBファイルのパス(未指定はメモリデータベースの指定と同じ)
  * @param init {mixed} DBを開いた時に実行するSQL(文字列 or 配列)
  * @param callback {Function} 引数無し
  */

  _open = function(dbname, init, callback) {
    if (init instanceof Function) {
      callback = init;
      init = void 0;
    }
    if (dbname instanceof Function) {
      callback = dbname;
      dbname = void 0;
      init = void 0;
    }
    if (dbname == null) {
      dbname = ':memory:';
    }
    if (_db != null) {
      return callback(_error(1007));
    }
    _db = new sqlite3.Database(dbname);
    if (init) {
      _onopen = init;
      return _postMulti(_onopen, callback);
    } else {
      return callback();
    }
  };
  /**
  * DBを閉じる
  *
  * @public
  * @method close
  * @param callback {Function} 引数無し
  */

  _close = function(callback) {
    if (_db == null) {
      return typeof callback === "function" ? callback() : void 0;
    }
    return _db.close(function(err) {
      if (err != null) {
        return typeof callback === "function" ? callback(err) : void 0;
      }
      _db = null;
      _onopen = null;
      return typeof callback === "function" ? callback() : void 0;
    });
  };
  _errMessage = {
    1001: 'unknown method',
    1002: 'forbidden',
    1003: 'invalid SQL type',
    1004: 'required param is not defined',
    1005: 'this SQL should be run on get()',
    1006: 'this SQL should be run on post()',
    1007: 'db is already opened',
    1008: 'db is not open'
  };
  /**
  * エラーオブジェクト作成
  *
  * - JSON化して送信するのでnew Error()で作成したエラーオブジェクトだと都合が悪い
  *
  * @private
  * @method _error
  * @param err sqlite3モジュールで発生したエラーオブジェクト、もしくはwebapiで発生したエラー番号
  * @param info {Object} エラーオブジェクトに付加する追加情報
  * @return {Object} エラーオブジェクト
  */

  _error = function(err, info) {
    var errObj, k, v, _ref, _ref1;

    if (info == null) {
      info = {};
    }
    if (err == null) {
      return void 0;
    }
    if (Type.number(err)) {
      errObj = {
        message: _errMessage[err],
        errno: err,
        code: 'WEBAPI_ERROR'
      };
    } else if (Type.string(err)) {
      errObj = {
        message: err,
        errno: 1000,
        code: 'WEBAPI_ERROR'
      };
    } else {
      errObj = {
        message: err.message.replace(/^SQLITE_ERROR:\s+/, ''),
        errno: (_ref = err.errno) != null ? _ref : 1000,
        code: (_ref1 = err.code) != null ? _ref1 : 'WEBAPI_ERROR'
      };
    }
    for (k in info) {
      v = info[k];
      errObj[k] = v;
    }
    return errObj;
  };
  /**
  * 読み取り系SQL実行
  *
  * @public
  * @method get
  * @param sql {String} SQL文字列
  * @param bind {mixed} バインドパラメータ(省略可)
  * @param callback {Function} (エラーオブジェクト, 取得データオブジェクト)
  */

  _get = function(sql, bind, callback) {
    if (bind instanceof Function) {
      callback = bind;
      bind = void 0;
    }
    if (Type.strnum(bind)) {
      bind = [bind];
    }
    if (_db == null) {
      return callback(_error(1008));
    }
    if (!Type.string(sql)) {
      return callback(_error(1003));
    }
    if (!/^\s*(select|pragma)/i.test(sql)) {
      return callback(_error(1006));
    }
    return _db.all(sql, bind, function(err, rows) {
      if (err != null) {
        return callback(_error(err, {
          sql: sql,
          bind: bind
        }));
      }
      return callback(void 0, rows);
    });
  };
  /**
  * 書き込み系SQL実行
  *
  * @public
  * @method post
  * @param sql {String} SQL文字列
  * @param bind {mixed} バインドパラメータ(省略可)
  * @param callback {Function} (エラーオブジェクト, 実行結果({sql, lastID, changes}))
  */

  _post = function(sql, bind, callback) {
    if (bind instanceof Function) {
      callback = bind;
      bind = void 0;
    }
    if (_db == null) {
      return callback(_error(1008));
    }
    if (!Type.string(sql)) {
      return callback(_error(1003));
    }
    if (/^\s*(select|pragma)/i.test(sql)) {
      return callback(_error(1005));
    }
    _db.run(sql, bind, function(err) {
      if (err != null) {
        return callback(_error(err, {
          sql: sql,
          bind: bind
        }));
      }
      return callback(void 0, this);
    });
  };
  /**
  * 書き込み系SQL実行(配列内のSQLを順番に実行)
  *
  * - パラメータのバインドは未実装
  *
  * @public
  * @method postMulti
  * @param sql {mixed} SQL文字列、又はそれらの配列
  * @param trans {Boolean} SQL配列をトランザクションの中で実行する
  * @param callback {Function} (エラーオブジェクト)
  */

  _postMulti = function(sql, trans, callback) {
    var results;

    if (trans instanceof Function) {
      callback = trans;
      trans = false;
    }
    if (!Type.array(sql)) {
      if (!Type.string(sql)) {
        return callback(_error(1003, {
          sql: sql
        }));
      }
      sql = [sql];
    }
    if (trans) {
      sql.unshift('begin');
      sql.push('commit');
    }
    results = [];
    return async.eachSeries(sql, function(item, next) {
      if (_db == null) {
        return next(_error(1008));
      }
      if (/^\s*select/i.test(item)) {
        return next(_error(1005));
      }
      return _db.run(item, function(err, info) {
        if (err != null) {
          return next(_error(err, {
            sql: item
          }, results));
        }
        results.push(info);
        return next();
      });
    }, function(err) {
      if ((err != null) && trans) {
        return _post('rollback', function() {
          return callback(err, results);
        });
      } else {
        return callback(err, results);
      }
    });
  };
  /**
  * CREATE TABLE文から項目リスト作成
  *
  * @private
  * @method _fieldsFromSql
  * @param sql {String} CREATE TABLE文
  */

  _fieldsFromSql = function(sql) {
    var f, fields, fld, m, mo, ms, mt, mv;

    fields = [];
    fld = sql.substr(sql.indexOf('(') + 1).replace(/\s+collate\s+nocase/ig, '').replace(/\)$/, '').split(',');
    m = 0;
    while (m < fld.length) {
      ms = fld[m].trim().replace(/primary\s+key/gi, 'primary_key true').replace(/\s*\(\s*/gi, '(').replace(/\s*\)/gi, ')').split(' ');
      f = {
        name: ms[0]
      };
      mt = ms[1].match(/^(.+)*\((\d+)\)/);
      if (mt) {
        f.type = mt[1];
        f.length = Number(mt[2]);
      } else {
        f.type = ms[1];
      }
      mo = 2;
      while (mo < ms.length) {
        mv = ms[mo + 1];
        if (/^\d+$/.test(mv)) {
          mv = Number(mv);
        }
        if (/^(true|false)$/.test(mv)) {
          mv = Boolean(mv);
        }
        if (mv === 'null') {
          mv = null;
        }
        f[ms[mo]] = mv;
        mo += 2;
      }
      fields.push(f);
      m++;
    }
    return fields;
  };
  /**
  * CREATE INDEX文から項目リスト作成
  *
  * @private
  * @method _indexesFromSql
  * @param sql {String} CREATE INDEX文
  */

  _indexesFromSql = function(sql) {
    return sql.substr(sql.indexOf('(') + 1).replace(/\s+collate nocase/ig, '').replace(/\)$/, '').replace(/\s/, '').split(',');
  };
  /**
  * スキーマ情報取得
  *
  * @public
  * @method schema
  * @param callback {Function} (エラーオブジェクト, スキーマ情報)
  */

  _schema = function(callback) {
    return _get('pragma database_list', function(err, dbList) {
      var schema;

      if (err != null) {
        return callback(err);
      }
      schema = {};
      return async.eachSeries(dbList, function(dItem, dNext) {
        var dbname, mSql;

        dbname = dItem.name;
        schema[dbname] = {
          path: dItem.file,
          tables: {},
          views: {}
        };
        mSql = "select * from " + dbname + ".sqlite_master where type = ?";
        return _get(mSql, 'table', function(err, tableList) {
          if (err != null) {
            return dNext(err);
          }
          return async.eachSeries(tableList, function(tItem, tNext) {
            var iSql, tblname;

            tblname = tItem.name;
            schema[dbname].tables[tblname] = {
              sql: tItem.sql,
              fields: _fieldsFromSql(tItem.sql),
              indexes: {}
            };
            iSql = "select * from " + dbname + ".sqlite_master where type = ? and tbl_name = ?";
            return _get(iSql, ['index', tblname], function(err, indexList) {
              var il, _i, _len;

              if (err != null) {
                return tNext(err);
              }
              for (_i = 0, _len = indexList.length; _i < _len; _i++) {
                il = indexList[_i];
                schema[dbname].tables[tblname].indexes[il.name] = _indexesFromSql(il.sql);
              }
              return tNext();
            });
          }, function(err) {
            if (err != null) {
              return dNext(err);
            }
            return _get(mSql, 'view', function(err, viewList) {
              var i, v, _i, _len;

              if (err != null) {
                return dNext(err);
              }
              for (i = _i = 0, _len = viewList.length; _i < _len; i = ++_i) {
                v = viewList[i];
                schema[dbname].views[v.name] = v.sql;
              }
              return dNext();
            });
          });
        });
      }, function(err) {
        if (err != null) {
          return callback(err);
        }
        return callback(void 0, schema);
      });
    });
  };
  /**
  * httpメソッドの追加
  *
  * @public
  * @method addMethod
  * @param path {String} リクエストパス('/xxxx')
  * @param func {Function} (param, callback)を受け、callbackで処理結果(エラーオブジェクト、実行結果)を返す関数
  * @return {Boolean} 成功/失敗
  */

  _addMethod = function(path, func) {
    if (!(func instanceof Function)) {
      return false;
    }
    _apiMethods[path] = func;
    return true;
  };
  /**
  * httpメソッドの削除
  *
  * @public
  * @method removeMethod
  * @param path {String} リクエストパス('/xxxx')
  * @return {Boolean} 成功/失敗
  */

  _removeMethod = function(path) {
    if (!(path in _apiMethods)) {
      return false;
    }
    delete _apiMethods[path];
    return true;
  };
  /**
  * httpメソッドの全消去
  *
  * @public
  * @method clearMethod
  */

  _clearMethod = function() {
    _apiMethods = {};
  };
  /**
  * httpメソッド一覧取得
  *
  * @public
  * @method methods
  * @return {Array} 登録メソッド一覧
  */

  _methods = function() {
    var path, _results;

    _results = [];
    for (path in _apiMethods) {
      _results.push(path);
    }
    return _results;
  };
  /**
  * httpリクエスト時のフック関数登録
  *
  * falseを返すとそのリクエストに対し403エラーを返す
  * 登録する関数は(remoteAddress, request)を受け、true or falseを返す関数
  *
  * @public
  * @method setHook
  * @param func {Function} フック関数(undefinedの場合は解除)
  * @return {Boolean} 成功/失敗
  */

  _setHook = function(func) {
    if (!(func instanceof Function)) {
      return false;
    }
    _requestHook = func;
    return true;
  };
  /**
  * httpインターフェースを公開
  *
  * @public
  * @method listen
  * @param port {Number} 待ち受けポート(デフォルト: 4983)
  * @param callback {Function} (エラーオブジェクト)
  */

  _listen = function(port, callback) {
    var resHeader,
      _this = this;

    if (port instanceof Function) {
      callback = port;
      port = void 0;
    }
    if (port == null) {
      port = 4983;
    }
    resHeader = {
      'Content-Type': 'application/json; charset=utf-8',
      'Connection': 'close'
    };
    _server = http.createServer(function(req, res) {
      var urlInfo;

      if (!_requestHook(req.headers['x-forwarded-for'] || req.client.remoteAddress, req)) {
        res.writeHead(403, resHeader);
        return res.end(JSON.stringify({
          error: _error(1002)
        }));
      }
      urlInfo = url.parse(req.url, true);
      urlInfo.pathname = urlInfo.pathname.toLowerCase();
      if (!_apiMethods[urlInfo.pathname]) {
        res.writeHead(404, resHeader);
        return res.end(JSON.stringify({
          error: _error(1001)
        }));
      }
      return _apiMethods[urlInfo.pathname].call(_this, urlInfo.query, function(err, result) {
        var body;

        res.writeHead((err != null ? 500 : 200), resHeader);
        body = void 0;
        if (!/head/i.test(req.method)) {
          body = JSON.stringify({
            error: _error(err, urlInfo.query),
            result: result
          });
          body = body.replace(/[\u007f-\uffff]/g, function(c) {
            return '\\u' + ('0000' + c.charCodeAt(0).toString(16)).slice(-4);
          });
        }
        return res.end(body);
      });
    });
    _server.listen(port);
    return typeof callback === "function" ? callback() : void 0;
  };
  /**
  * httpサーバー終了
  *
  * @public
  * @method shutdown
  * @param callback {Function} (エラーオブジェクト)
  */

  _shutdown = function(callback) {
    if (_server != null) {
      _server.close();
    }
    _server = null;
    return typeof callback === "function" ? callback() : void 0;
  };
  return {
    dbname: _dbname,
    open: _open,
    close: _close,
    get: _get,
    post: _post,
    postMulti: _postMulti,
    schema: _schema,
    addMethod: _addMethod,
    removeMethod: _removeMethod,
    clearMethod: _clearMethod,
    methods: _methods,
    setHook: _setHook,
    listen: _listen,
    shutdown: _shutdown
  };
})();

module.exports = Sqlite3WebApiKit;
